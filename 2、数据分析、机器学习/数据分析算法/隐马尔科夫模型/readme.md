# 隐马尔可夫模型


## `马尔科夫性质：`


* 马尔科夫链遵从马尔可夫性质：也就是未来状态的条件概率分布只依赖于当前时刻：

    <div align=center><img  src="./static/马尔可夫性质.jpg"/></div>



## `马尔可夫模型：`

* 既然某一时刻状态转移的概率只依赖于它的前一个状态，那么我们只要能求出系统中任意两个状态之间的转换概率，这个马尔科夫链的模型就定了。

* 下图马尔科夫链是表示股市模型的，共有三种状态：牛市（Bull market）, 熊市（Bear market）和横盘（Stagnant market）。每一个状态都以一定的概率转化到下一个状态。比如，牛市以0.025的概率转化到横盘的状态。这个状态概率转化图可以以矩阵的形式表示。如果我们定义矩阵阵P某一位置P(i,j)的值为P(j|i),即从状态i转化到状态j的概率，并定义牛市为状态0， 熊市为状态1, 横盘为状态2. 这样我们得到了马尔科夫链模型的状态转移矩阵。

    <div align=center><img  src="./static/马尔科夫链.png"/></div>


* 有了状态转移矩阵之后就可以预测下一次的状态的概率是多少，比如今天 `牛市的概率为30%` ， `熊盘的概率为40%` ，`横盘的概率为30%` ，也就是 `[0.3,0.4,0.3]`


    然后这个状态作为序列概率分布的 `初始状态 t0 [0.3,0.4,0.3]`，将其带入这个状态转移矩阵计算 `t1` , `t2` , `t3` ...的状态。

    下一个状态依赖于当前状态：`t1 = t0 * 状态转移矩阵`


### 代码示例：

    import numpy as np
    matrix = np.matrix([[0.9,0.075,0.025],[0.15,0.8,0.05],[0.25,0.25,0.5]], dtype=float)
    vector1 = np.matrix([[0.3,0.4,0.3]], dtype=float)
    for i in range(100):
        vector1 = vector1 * matrix
        print("Current round:" , i+1)
        print(vector1)

    --> 60次轮询后，可以看到最后得到的状态概率分布已经不变，成为平稳分布。<--

    Current round: 1
    [[ 0.405   0.4175  0.1775]]
    Current round: 2
    [[ 0.4715   0.40875  0.11975]]
    Current round: 3
    [[ 0.5156  0.3923  0.0921]]
    Current round: 4
    [[ 0.54591   0.375535  0.078555]]
    。。。。。。
    Current round: 58
    [[ 0.62499999  0.31250001  0.0625    ]]
    Current round: 59
    [[ 0.62499999  0.3125      0.0625    ]]
    Current round: 60
    [[ 0.625   0.3125  0.0625]]
    。。。。。。
    Current round: 99
    [[ 0.625   0.3125  0.0625]]
    Current round: 100
    [[ 0.625   0.3125  0.0625]]



### `马尔科夫链模型状态转移矩阵的性质`

* 不论你当前状态是什么，通过状态转移矩阵，最后都能得到一个平稳的概率分布。也就是说我们的马尔科夫链模型的状态转移矩阵收敛到的稳定概率分布与我们的初始状态概率分布无关。


### `马尔可夫状态转移矩阵`

* 马尔可夫状态转移矩阵必须满足：所有状态可遍历性和非周期性。

   <div align=center><img  src="./static/马尔科夫状态转移矩阵.jpg"/></div>




## `参考：`


* MCMC(二)马尔科夫链：https://www.cnblogs.com/pinard/p/6632399.html

* 隐马尔科夫模型详解：https://www.bilibili.com/video/BV13C4y1W7iB