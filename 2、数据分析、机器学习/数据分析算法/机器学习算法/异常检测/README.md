## 异常检测

### 高斯分布

![Image_text](https://raw.githubusercontent.com/OneStepAndTwoSteps/data_mining_analysis/master/static/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/1.png)

假设x是一个实数的随机变量，如果x的概率分布服从高斯分布，其中的均值为μ，方差为σ平方，那么随机变量x波浪号(~)这个波浪号读为什么的分布，如果表示为高斯分布我们通常使用大写字母N括号μ，σ平方，大写字母N表示Normal(正态)高斯分布就是正态分布，高斯函数中有两个参数一个是均值(μ)一个是方差(σ平方) (红色框中的内容)

如果我们将高斯分布的概率密度绘制出来，那么就是我们上面这个钟状曲线图，μ控制着曲线图的中心位置，σ控制这个钟型曲线的宽度，σ有时候也被称为标准差，这条钟型曲线决定了x取不同值时的概率，因此x取中心这些值的时候，输出的概率会很大，因为高斯分布的概率密度在这里很大，而x取远处和更远处的值时概率将逐渐降低直至消失。

绿色框部分表示我们的高斯概率分布P(x;μ，σ平方)表示x的概率由μ和σ平方决定，这个式子就是我们钟型曲线的式子

__高斯分布样例：__

接下来让我们看一下高斯分布的样例，这几个图分别是μ和σ值不同画出的不同的高斯分布曲线。

![Image_text](https://raw.githubusercontent.com/OneStepAndTwoSteps/data_mining_analysis/master/static/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/2.png)

图一是高斯分布μ取0和σ值取1时候的高斯分布曲线，因为μ取0，我们的中心点就在0这个位置。

图二是μ取0和σ值取0.5时候的高斯分布曲线，因为是高斯分布是概率分布，那么我们图形的阴影部分的面积一定为1(红色阴影部分)，因为我们的标准差是之间的一半(和图一相比)，那么我们宽度也是之前的一般，但是因为面积等于1，那么我们的高度要是之前的2倍

接下来同理

__参数估计:__

![Image_text](https://raw.githubusercontent.com/OneStepAndTwoSteps/data_mining_analysis/master/static/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/3.png)

现在假设我们有一个数据集x1到xm，假设他们都是实数，我们这里画一个图其中横轴为x，参数估计就是，假设我们这些样本服从高斯分布的总体，我们知道高斯分布的曲线是由μ和σ平方决定，我们职高估计出参数我们就可以画出高斯分布曲线，参数估计问题就是让我们通过一个数据集估计出这两个参数，画出高斯分布曲线。右上角是我们参数估计的公式，通过公式我们可以画出高斯分布曲线。

### 异常检测算法

接下来我们通过高斯分布推出异常检测算法

![Image_text](https://raw.githubusercontent.com/OneStepAndTwoSteps/data_mining_analysis/master/static/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/4.png)

看上图这个异常检测的案例，首先我们看特征变量x1，我们可以通过μ1和σ1估计出他的高斯分布，同理我们可以估计出变量2(x2)的高斯分布曲线，就是我们右侧画出的曲线，实际上如果画出p(x)的图像的话，也就是两个的乘积p(x1),p(x2),之后你就会得到一个左下图这样的一个3D曲线，此时我们给出一个x1和x2的值，我们可以的得到p(x)

接下来我们如何判断是否异常呢？我们通常设置一个值(ε)，之后我们会讲如何设置，这里我们将其设置为0.02，我们在选择出两个样本(x^(1)test和x^(2)test)当我们得出的概率p(x)大于0.02时我们将其看为正常，如果小于0.02我们将其视为异常。这里我们可以看出p(x^(1)test)为正常，p(x^(2)test)为异常。


### 开发和评估异常检测系统

异常检测算法是一个非监督学习算法，意味着我们无法根据结果变量 𝑦 的值来告诉我们数据是否真的是异常的。我们需要另一种方法来帮助检验算法是否有效。当我们开发一个异常检测系统时，我们从带标记（异常或正常）的数据着手，我们从其中选择一部分正常数据用于构建训练集，然后用剩下的正常数据和异常数据混合的数据构成交叉检验集和测试集。

例如：我们有 10000 台正常引擎的数据，有 20 台异常引擎的数据。 我们这样分配数： 
6000 台正常引擎的数据作为训练集 
2000 台正常引擎和 10 台异常引擎的数据作为交叉检验集 
2000 台正常引擎和 10 台异常引擎的数据作为测试集 

__具体的评价方法如下:__
1. 根据测试集数据，我们估计特征的平均值和方差并构建𝑝(𝑥)函数 
2. 对交叉检验集，我们尝试使用不同的值作为阀值，并预测数据是否异常，根据 F1 值
或者查准率与查全率的比例来选择  
3. 选出  后，针对测试集进行预测，计算异常检验系统的𝐹1值，或者查准率与查全率
之比。 

### 异常检测 VS 监督学习

我们之前举的例子都是带标签的样本，那么为什么我们不直接使用逻辑回归或者神经网络算法来直接尝试学习样本判断y=0或者y=1呢，接下来我们会讲一些思想和方法，当你使用异常检测算法时能够用上这些方法，并且在使用监督学习时，这些方法可能更有效

![Image_text](https://raw.githubusercontent.com/OneStepAndTwoSteps/data_mining_analysis/master/static/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/15.png)


### 选择特征 

之前我们在讲了异常检测算法，但是实际上如果我们使用异常检测算法时 选择了什么特征会对运行有很大影响

![Image_text](https://raw.githubusercontent.com/OneStepAndTwoSteps/data_mining_analysis/master/static/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/5.png)

在异常检测算法中我们所做的其中一件事是使用高斯分布来对特征进行建模，假设其函数x_j的期望是μ_i方差是σ_i平方，我们经常会画出数据图，确保这些数据在进入异常检测算法之前看上去接近高斯分布。虽然说不是高斯分布也可以运行，但是效果肯定没有那么好。

如果我们画出的数据图像左下角这样的数据图，我们通常需要对数据进行一些不同的转换，使其看上去更接近高斯分布，比如进行对数转换，当然不只有对数转换这一种方法，我们可以我们可以使用平方根(x=x^(1/2))、立方根(x=x^(1/3))等方法来转换。

按照我们之间的思路进行异常检测其实是有一些问题的，一个常见的问题是一些异常的数据可能也会有较高的𝑝(𝑥)值，因而被算法认为是正常的。这种情况下误差分析能够帮助我们，我们可以分析那些被算法错误预测为正常的数据，观察能否找出一些问题。我们可能能从问题中发现我们需要增加一些新的特征，增加这些新特征后获得的新算法能够帮助我们更好地进行异常检测。 

__异常检测误差分析:__

![Image_text](https://raw.githubusercontent.com/OneStepAndTwoSteps/data_mining_analysis/master/static/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/6.png)

图中的绿色样本为我们的异常样本，我们可以看出异常样本p(x)也很高，当出现这样的情况的时候，我们通常会去看训练样本，找出哪一个具体的飞机引擎出错，通过这个样本我们想要找出一个新的特征x2，来帮助算法找出异常样本和正常样本之间的区别

通过特征x1和x2，我们可以画出样本的分布图(右图)，右图中的红色x就是我们的样本，从右图中我们可以想象出高斯分布是一个什么形状，用粉色的圆圈圈出就是我们越内测的圆圈我们的概率越高，越外面我们的概率越低，图中我们可以发现我们的异常样本在我们这个新的图像中所占的概率很小，我们可以将其视为异常样本。

这就是我们异常检查误差分析的过程

__异常检测算法特征选择:__

1、通常进行特征的选择的时候我们都不会去选择那些特别大或者特别小的特征，我们这里使用监控数据中心的计算机的例子，假设在一个数据中心中，你有很多电脑，我们想要知道的是，如果有一台电脑出现故障(故障包括：占用内存、磁盘每秒访问次数、cpu负载、网络流量)现在如果说我怀疑每个出错的地方在我的数据集中，我们的CPU负载和网络流量应该互为线性关系，可能我运行了一组网络服务器，如果其中一台服务器正在服务多个用户，你那么我们的cpu负载和我们的网络流量就会很高，但是现在我判断其中一个出错的地方在，我的计算机在z还行一个任务时进入了一个死循环，此时我们的cpu负载升高，但是我们的网络流量却没有升高，这个时候，我们可以建立一个新特征x5代表cpu负载/网络流量此时我们就可以解决我们上述的问题，当我们的x5很高时，便有可能意味着该服务器是陷入了一些问题中。 


2、在这里我们介绍了如何选择特征，以及对特征进行一些小小的转换，让数据更像正态分布，然后再把数据输入异常检测算法。同时也介绍了建立特征时，进行的误差分析方法，来捕捉各种异常的可能。希望你通过这些方法，能够了解如何选择好的特征变量，从而帮助你的异常检测算法，捕捉到各种不同的异常情况。 


### 多变量高斯分布

![Image_text](https://raw.githubusercontent.com/OneStepAndTwoSteps/data_mining_analysis/master/static/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/7.png)

x1是我们的cpu负载，x2是我们的内存占用情况，正常来说我们画出来的高斯分布图应该是蓝线这样的分布图，但是一般的高斯分布模型会画出洋红色这样的分布图，很明显绿色的 X 所代表的数据点很可能是异常值，但是其𝑝(𝑥)值却仍然在正常范围内。但是这样的高斯分布图是有问题的，所以我们需要对我们原先的异常检测模型进行一个改进，这个时候我们使用多元高斯分布，多元高斯分布将创建像图中蓝色曲线所示的判定边界。

在一般的高斯分布模型中，我们计算 𝑝(𝑥) 的方法是： 通过分别计算每个特征对应的几率然后将其累乘起来，__在多元高斯分布模型中，我们将构建特征的协方差矩阵，用所有的特征一起来计算 𝑝(𝑥)。__ 

我们首先计算所有特征的平均值，然后再计算协方差矩阵

![Image_text](https://raw.githubusercontent.com/OneStepAndTwoSteps/data_mining_analysis/master/static/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/16.png)

其中𝜇 是一个向量，其每一个单元都是原特征矩阵中一行数据的均值。最后我们计 算多元高斯分布的𝑝(𝑥):

![Image_text](https://raw.githubusercontent.com/OneStepAndTwoSteps/data_mining_analysis/master/static/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/17.png)


__下面我们来看看协方差矩阵是如何影响模型的:__


![Image_text](https://raw.githubusercontent.com/OneStepAndTwoSteps/data_mining_analysis/master/static/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/8.png)

上图是 5 个不同的模型，从左往右依次分析： 

1. 是一个一般的高斯分布模型 
2. 通过协方差矩阵，衡量方差，或者说特征变量x1和x2的变化量，所以如果缩小Σ，那么结果就是这个钟状图的宽度会减小，高度增加，因为体积的积分要等于1
3. 通过协方差矩阵，缩大Σ，那么结果就是这个钟状图的宽度会增大，高度减小，因为体积的积分要等于1
4. 通过协方差矩阵，只改变协方差矩阵的单个元素，意思是说减小了第一个特征变量x1的方差，同时保持第二个特征变量x2的方差不变，此时x1就有了一个较小的方差，x2有了一个较大的方差
5. 通过协方差矩阵，只改变协方差矩阵的单个元素，意思是说增大了第一个特征变量x1的方差，同时保持第二个特征变量x2的方差不变，此时x1就有了一个较大的方差，x2有了一个较小的方差


![Image_text](https://raw.githubusercontent.com/OneStepAndTwoSteps/data_mining_analysis/master/static/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/9.png)

多元高斯分布很棒的事情在于你可以用它给数据的相关性建立模型，我们可以用它来给x1和x2高度相关的情况建立模型，所以具体的说如果你改变协方差矩阵非对角线上的元素你会得到一种不同的高斯分布，当我将非对角线上的元素从0.5变为0.8时，我会得到一个更加窄和高的沿着x=y这条线的分布，然后这个等高线图告诉我们，x和y看起来是一起增加的。像最右边这个图就是一个很高很细的分布，几乎都在中间，x接近y的区间内


![Image_text](https://raw.githubusercontent.com/OneStepAndTwoSteps/data_mining_analysis/master/static/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/10.png)

当我们将非对角线上的值设为负值时，我们会得到这样的等高线图


![Image_text](https://raw.githubusercontent.com/OneStepAndTwoSteps/data_mining_analysis/master/static/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/11.png)

当我们改变μ值我们的峰值位置会发生改变

__回顾多元高斯分布:__

![Image_text](https://raw.githubusercontent.com/OneStepAndTwoSteps/data_mining_analysis/master/static/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/12.png)

多元高斯分布有两个参数， 𝜇 和 𝛴。其中𝜇这一个𝑛维向量和 𝛴 的协方差矩阵，是一种𝑛 × 𝑛的矩阵。而这里的公式𝑥的概率，如按 𝜇 和参数化 𝛴，和你的变量 𝜇 和 𝛴，你可以得到一个范围的不同分布。

因此，让我们谈谈参数拟合或参数估计问题： 
我有一组样本𝑥(1),𝑥(2),...,𝑥(𝑚)是一个𝑛维向量，我想我的样本来自一个多元高斯分布。我如何尝试估计我的参数 𝜇 和 𝛴 以及标准公式？ 
估计他们是你设置 𝜇 是你的训练样本的平均值。 就是上面的公式
并设置𝛴： 上面的公式

此时我们就得到了两个参数的值，然后将其带入到异常检测算法中


![Image_text](https://raw.githubusercontent.com/OneStepAndTwoSteps/data_mining_analysis/master/static/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/13.png)

如果我们将多元高斯分布拟合到图形中，我们可以得到这样的一个等高线图，可以看出此时我们的异常样本可以被正确的识别出来了


![Image_text](https://raw.githubusercontent.com/OneStepAndTwoSteps/data_mining_analysis/master/static/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/14.png)

原始模型和多元高斯分布模型的区别在于这些椭圆形他们的轴都是与x1轴和x2轴对齐的，而不是有角度的轴所对应的样本(红色框)

实际上原始模型就是特殊情况下的多元高斯模型，这个情形就是我们的Σ(协方差矩阵)对角线都为σ平方，其他的位置都为0，这样的矩阵时就是我们的原始模型(绿色框)


__如何选择使用多元高斯模型和原始模型__

当出现像之前分析的的cpu负载和网络流量这样的问题时，原始模型就需要创建一个新的特征x3=x1/x2，原始模型无法判断出x1和x2之间的关系，单个看x1和x2的话我们可能会觉得它是正常的。但是多元高斯模型可以帮助我们分析x1和x2之间的联系，可以判断出异常。

原始模型最大的有点在于它的记算成本低，能适应大规模的特征，当特征量n取10000或者100000时都可以运行的很好，相比之下多元高斯模型需要计算协方差矩阵的逆矩阵，如果他计算的Σ是一个100000*100000的矩阵，那么计算成本将会非常高昂，所以多元高斯模型能适应的n值范围较小。

原始模型即使我们的即使你的训练集较小也能顺利运行，即使n的值只有50，100也可以工作的很好。但是对于多元高斯分布，因为数学性质，我们的m需要大于n(最好远大于)，也就是样本的数量要大于特征的数量，如果在估计参数时，我们不满足这个数学性质，那么这个矩阵就是不可逆的，那么意味着我们无法使用多元高斯函数

一般来说原始模型我们运用的更多，当我们的样本数远大于我们的特征数我一般会多考虑多元高斯模型，因为这样可以节省我们创建新特征所消耗的时间

这里提一点，如果在使用多元高斯分布时，你的矩阵是不可逆的那么，有两种情况可能导致这样，一、m没有大于n 二、存在冗余的特征，意思就是比如你有两个相同的特征即x1=x2，或者有像x3=x4+x5这种特征

